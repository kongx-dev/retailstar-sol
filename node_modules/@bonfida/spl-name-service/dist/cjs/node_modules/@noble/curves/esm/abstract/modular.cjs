"use strict";var e=require("../../../hashes/esm/utils.cjs"),t=require("./utils.cjs");
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=BigInt(0),n=BigInt(1),o=BigInt(2),i=BigInt(3),s=BigInt(4),u=BigInt(5),l=BigInt(8);function f(e,t){const n=e%t;return n>=r?n:t+n}function d(e,t){if(e===r)throw new Error("invert: expected non-zero number");if(t<=r)throw new Error("invert: expected positive modulus, got "+t);let o=f(e,t),i=t,s=r,u=n;for(;o!==r;){const e=i%o,t=s-u*(i/o);i=o,o=e,s=u,u=t}if(i!==n)throw new Error("invert: does not exist");return f(s,t)}function c(e,t){const r=(e.ORDER+n)/s,o=e.pow(t,r);if(!e.eql(e.sqr(o),t))throw new Error("Cannot find square root");return o}function E(e,t){const r=(e.ORDER-u)/l,n=e.mul(t,o),i=e.pow(n,r),s=e.mul(t,i),f=e.mul(e.mul(s,o),i),d=e.mul(s,e.sub(f,e.ONE));if(!e.eql(e.sqr(d),t))throw new Error("Cannot find square root");return d}function a(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let t=e-n,i=0;for(;t%o===r;)t/=o,i++;let s=o;const u=b(e);for(;1===h(u,s);)if(s++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===i)return c;let l=u.pow(s,t);const f=(t+n)/o;return function(e,r){if(e.is0(r))return r;if(1!==h(e,r))throw new Error("Cannot find square root");let o=i,s=e.mul(e.ONE,l),u=e.pow(r,t),d=e.pow(r,f);for(;!e.eql(u,e.ONE);){if(e.is0(u))return e.ZERO;let t=1,r=e.sqr(u);for(;!e.eql(r,e.ONE);)if(t++,r=e.sqr(r),t===o)throw new Error("Cannot find square root");const i=n<<BigInt(o-t-1),l=e.pow(s,i);o=t,s=e.sqr(l),u=e.mul(u,s),d=e.mul(d,l)}return d}}function w(e){return e%s===i?c:e%l===u?E:a(e)}const p=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function g(e,t,o){if(o<r)throw new Error("invalid exponent, negatives unsupported");if(o===r)return e.ONE;if(o===n)return t;let i=e.ONE,s=t;for(;o>r;)o&n&&(i=e.mul(i,s)),s=e.sqr(s),o>>=n;return i}function m(e,t,r=!1){const n=new Array(t.length).fill(r?e.ZERO:void 0),o=t.reduce(((t,r,o)=>e.is0(r)?t:(n[o]=t,e.mul(t,r))),e.ONE),i=e.inv(o);return t.reduceRight(((t,r,o)=>e.is0(r)?t:(n[o]=e.mul(t,n[o]),e.mul(t,r))),i),n}function h(e,t){const r=(e.ORDER-n)/o,i=e.pow(t,r),s=e.eql(i,e.ONE),u=e.eql(i,e.ZERO),l=e.eql(i,e.neg(e.ONE));if(!s&&!u&&!l)throw new Error("invalid Legendre symbol result");return s?1:u?0:-1}function q(t,r){void 0!==r&&e.anumber(r);const n=void 0!==r?r:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function b(e,o,i=!1,s={}){if(e<=r)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:u,nByteLength:l}=q(e,o);if(l>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const E=Object.freeze({ORDER:e,isLE:i,BITS:u,BYTES:l,MASK:t.bitMask(u),ZERO:r,ONE:n,create:t=>f(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return r<=t&&t<e},is0:e=>e===r,isOdd:e=>(e&n)===n,neg:t=>f(-t,e),eql:(e,t)=>e===t,sqr:t=>f(t*t,e),add:(t,r)=>f(t+r,e),sub:(t,r)=>f(t-r,e),mul:(t,r)=>f(t*r,e),pow:(e,t)=>g(E,e,t),div:(t,r)=>f(t*d(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>d(t,e),sqrt:s.sqrt||(t=>(c||(c=w(e)),c(E,t))),toBytes:e=>i?t.numberToBytesLE(e,l):t.numberToBytesBE(e,l),fromBytes:e=>{if(e.length!==l)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+e.length);return i?t.bytesToNumberLE(e):t.bytesToNumberBE(e)},invertBatch:e=>m(E,e),cmov:(e,t,r)=>r?t:e});return Object.freeze(E)}exports.Field=b,exports.FpInvertBatch=m,exports.FpLegendre=h,exports.FpPow=g,exports.FpSqrt=w,exports.invert=d,exports.isNegativeLE=(e,t)=>(f(e,t)&n)===n,exports.mod=f,exports.nLength=q,exports.pow2=function(e,t,n){let o=e;for(;t-- >r;)o*=o,o%=n;return o},exports.tonelliShanks=a,exports.validateField=function(e){const r=p.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return t.validateObject(e,r)};
//# sourceMappingURL=modular.cjs.map
