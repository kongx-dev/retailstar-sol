{"version":3,"file":"modular.cjs","sources":["../../../../../../../node_modules/@noble/curves/esm/abstract/modular.js"],"sourcesContent":["/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { anumber } from '@noble/hashes/utils';\nimport { bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, validateObject, } from \"./utils.js\";\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3))\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P ≡ 3 (mod 4) => √n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P ≡ 9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map"],"names":["_0n","BigInt","_1n","_2n","_3n","_4n","_5n","_8n","mod","a","b","result","invert","number","modulo","Error","x","u","r","m","sqrt3mod4","Fp","n","p1div4","ORDER","root","pow","eql","sqr","sqrt5mod8","p5div8","n2","mul","v","nv","i","sub","ONE","tonelliShanks","P","Q","S","Z","_Fp","Field","FpLegendre","cc","Q1div2","is0","M","c","t","R","ZERO","t_tmp","exponent","FpSqrt","FIELD_FIELDS","FpPow","num","power","p","d","FpInvertBatch","nums","passZero","inverted","Array","length","fill","undefined","multipliedAcc","reduce","acc","invertedAcc","inv","reduceRight","p1mod2","powered","yes","zero","no","neg","nLength","nBitLength","anumber","_nBitLength","toString","nByteLength","Math","ceil","bitLen","isLE","redef","BITS","BYTES","sqrtP","f","Object","freeze","MASK","bitMask","create","isValid","isOdd","lhs","rhs","add","div","sqrN","addN","subN","mulN","sqrt","toBytes","numberToBytesLE","numberToBytesBE","fromBytes","bytes","bytesToNumberLE","bytesToNumberBE","invertBatch","lst","cmov","isNegativeLE","res","field","opts","map","val","validateObject"],"mappings":"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","x_google_ignoreList":[0]}