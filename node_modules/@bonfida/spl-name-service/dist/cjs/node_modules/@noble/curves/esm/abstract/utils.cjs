"use strict";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const t=BigInt(0),r=BigInt(1);function e(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function n(t){if(!e(t))throw new Error("Uint8Array expected")}function o(r){if("string"!=typeof r)throw new Error("hex string expected, got "+typeof r);return""===r?t:BigInt("0x"+r)}const i="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,s=Array.from({length:256},((t,r)=>r.toString(16).padStart(2,"0")));function f(t){if(n(t),i)return t.toHex();let r="";for(let e=0;e<t.length;e++)r+=s[t[e]];return r}const c=48,u=57,a=65,p=70,g=97,y=102;function x(t){return t>=c&&t<=u?t-c:t>=a&&t<=p?t-(a-10):t>=g&&t<=y?t-(g-10):void 0}function h(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(i)return Uint8Array.fromHex(t);const r=t.length,e=r/2;if(r%2)throw new Error("hex string expected, got unpadded hex of length "+r);const n=new Uint8Array(e);for(let r=0,o=0;r<e;r++,o+=2){const e=x(t.charCodeAt(o)),i=x(t.charCodeAt(o+1));if(void 0===e||void 0===i){const r=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+r+'" at index '+o)}n[r]=16*e+i}return n}function l(t,r){return h(t.toString(16).padStart(2*r,"0"))}const d=r=>"bigint"==typeof r&&t<=r;function w(t,r,e){return d(t)&&d(r)&&d(e)&&r<=t&&t<e}const b={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||e(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,r)=>r.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};exports.aInRange=function(t,r,e,n){if(!w(r,e,n))throw new Error("expected valid "+t+": "+e+" <= n < "+n+", got "+r)},exports.abool=function(t,r){if("boolean"!=typeof r)throw new Error(t+" boolean expected, got "+r)},exports.abytes=n,exports.bitLen=function(e){let n;for(n=0;e>t;e>>=r,n+=1);return n},exports.bitMask=t=>(r<<BigInt(t))-r,exports.bytesToHex=f,exports.bytesToNumberBE=function(t){return o(f(t))},exports.bytesToNumberLE=function(t){return n(t),o(f(Uint8Array.from(t).reverse()))},exports.concatBytes=function(...t){let r=0;for(let e=0;e<t.length;e++){const o=t[e];n(o),r+=o.length}const e=new Uint8Array(r);for(let r=0,n=0;r<t.length;r++){const o=t[r];e.set(o,n),n+=o.length}return e},exports.ensureBytes=function(t,r,n){let o;if("string"==typeof r)try{o=h(r)}catch(r){throw new Error(t+" must be hex string or Uint8Array, cause: "+r)}else{if(!e(r))throw new Error(t+" must be hex string or Uint8Array");o=Uint8Array.from(r)}const i=o.length;if("number"==typeof n&&i!==n)throw new Error(t+" of length "+n+" expected, got "+i);return o},exports.hexToBytes=h,exports.hexToNumber=o,exports.inRange=w,exports.isBytes=e,exports.memoized=function(t){const r=new WeakMap;return(e,...n)=>{const o=r.get(e);if(void 0!==o)return o;const i=t(e,...n);return r.set(e,i),i}},exports.numberToBytesBE=l,exports.numberToBytesLE=function(t,r){return l(t,r).reverse()},exports.validateObject=function(t,r,e={}){const n=(r,e,n)=>{const o=b[e];if("function"!=typeof o)throw new Error("invalid validator function");const i=t[r];if(!(n&&void 0===i||o(i,t)))throw new Error("param "+String(r)+" is invalid. Expected "+e+", got "+i)};for(const[t,e]of Object.entries(r))n(t,e,!1);for(const[t,r]of Object.entries(e))n(t,r,!0);return t};
//# sourceMappingURL=utils.cjs.map
