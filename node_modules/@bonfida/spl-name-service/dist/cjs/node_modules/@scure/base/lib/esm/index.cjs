"use strict";
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function r(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name}function e(r,e){return!!Array.isArray(e)&&(0===e.length||(r?e.every((r=>"string"==typeof r)):e.every((r=>Number.isSafeInteger(r)))))}function o(r,e){if("string"!=typeof e)throw new Error(`${r}: string expected`);return!0}function n(r){if(!Number.isSafeInteger(r))throw new Error(`invalid integer: ${r}`)}function t(r){if(!Array.isArray(r))throw new Error("array expected")}function i(r,o){if(!e(!0,o))throw new Error(`${r}: array of strings expected`)}function c(r,o){if(!e(!1,o))throw new Error(`${r}: array of numbers expected`)}const d=(r,e)=>0===e?r:d(e,r%e),f=(r,e)=>r+(e-d(r,e)),s=(()=>{let r=[];for(let e=0;e<40;e++)r.push(2**e);return r})();function a(r,e,o,i){if(t(r),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(o<=0||o>32)throw new Error(`convertRadix2: wrong to=${o}`);if(f(e,o)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${o} carryBits=${f(e,o)}`);let c=0,d=0;const a=s[e],w=s[o]-1,u=[];for(const t of r){if(n(t),t>=a)throw new Error(`convertRadix2: invalid data word=${t} from=${e}`);if(c=c<<e|t,d+e>32)throw new Error(`convertRadix2: carry overflow pos=${d} from=${e}`);for(d+=e;d>=o;d-=o)u.push((c>>d-o&w)>>>0);const r=s[d];if(void 0===r)throw new Error("invalid carry");c&=r-1}if(c=c<<o-d&w,!i&&d>=e)throw new Error("Excess padding");if(!i&&c>0)throw new Error(`Non-zero padding: ${c}`);return i&&d>0&&u.push(c>>>0),u}function w(r){return function(r){if("function"!=typeof r)throw new Error("function expected")}(r),function(...e){try{return r.apply(null,e)}catch(r){}}}const u=function(...r){const e=r=>r,o=(r,e)=>o=>r(e(o));return{encode:r.map((r=>r.encode)).reduceRight(o,e),decode:r.map((r=>r.decode)).reduce(o,e)}}(function(r){const e="string"==typeof r?r.split(""):r,n=e.length;i("alphabet",e);const c=new Map(e.map(((r,e)=>[r,e])));return{encode:o=>(t(o),o.map((o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${r}`);return e[o]}))),decode:e=>(t(e),e.map((e=>{o("alphabet.decode",e);const n=c.get(e);if(void 0===n)throw new Error(`Unknown letter: "${e}". Allowed: ${r}`);return n})))}}("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),function(r=""){return o("join",r),{encode:e=>(i("join.decode",e),e.join(r)),decode:e=>(o("join.decode",e),e.split(r))}}("")),h=[996825010,642813549,513874426,1027748829,705979059];function l(r){const e=r>>25;let o=(33554431&r)<<5;for(let r=0;r<h.length;r++)1==(e>>r&1)&&(o^=h[r]);return o}function p(r,e,o=1){const n=r.length;let t=1;for(let e=0;e<n;e++){const o=r.charCodeAt(e);if(o<33||o>126)throw new Error(`Invalid prefix (${r})`);t=l(t)^o>>5}t=l(t);for(let e=0;e<n;e++)t=l(t)^31&r.charCodeAt(e);for(let r of e)t=l(t)^r;for(let r=0;r<6;r++)t=l(t);return t^=o,u.encode(a([t%s[30]],30,5,!1))}const y=function(e){const t="bech32"===e?1:734539939,i=function(e,o=!1){if(n(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(f(8,e)>32||f(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!r(n))throw new Error("radix2.encode input should be Uint8Array");return a(Array.from(n),8,e,!o)},decode:r=>(c("radix2.decode",r),Uint8Array.from(a(r,e,8,o)))}}(5),d=i.decode,s=i.encode,h=w(d);function l(e,n,i=90){o("bech32.encode prefix",e),r(n)&&(n=Array.from(n)),c("bech32.encode",n);const d=e.length;if(0===d)throw new TypeError(`Invalid prefix length ${d}`);const f=d+7+n.length;if(!1!==i&&f>i)throw new TypeError(`Length ${f} exceeds limit ${i}`);const s=e.toLowerCase(),a=p(s,n,t);return`${s}1${u.encode(n)}${a}`}function y(r,e=90){o("bech32.decode input",r);const n=r.length;if(n<8||!1!==e&&n>e)throw new TypeError(`invalid string length: ${n} (${r}). Expected (8..${e})`);const i=r.toLowerCase();if(r!==i&&r!==r.toUpperCase())throw new Error("String must be lowercase or uppercase");const c=i.lastIndexOf("1");if(0===c||-1===c)throw new Error('Letter "1" must be present between prefix and data only');const d=i.slice(0,c),f=i.slice(c+1);if(f.length<6)throw new Error("Data must be at least 6 characters long");const s=u.decode(f).slice(0,-6),a=p(d,s,t);if(!f.endsWith(a))throw new Error(`Invalid checksum in ${r}: expected "${a}"`);return{prefix:d,words:s}}return{encode:l,decode:y,encodeFromBytes:function(r,e){return l(r,s(e))},decodeToBytes:function(r){const{prefix:e,words:o}=y(r,!1);return{prefix:e,words:o,bytes:d(o)}},decodeUnsafe:w(y),fromWords:d,fromWordsUnsafe:h,toWords:s}}("bech32");exports.bech32=y;
//# sourceMappingURL=index.cjs.map
