{"version":3,"file":"curve.mjs","sources":["../../../../../../../node_modules/@noble/curves/esm/abstract/curve.js"],"sourcesContent":["/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { nLength, validateField } from \"./modular.js\";\nimport { bitLen, bitMask, validateObject } from \"./utils.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                }\n                else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                if (n === _0n)\n                    break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // Window bits are 0: skip processing.\n                    // Move to next window.\n                    continue;\n                }\n                else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map"],"names":["_0n","BigInt","_1n","constTimeNegate","condition","item","neg","negate","validateW","W","bits","Number","isSafeInteger","Error","calcWOpts","scalarBits","maxNumber","windows","Math","ceil","windowSize","mask","bitMask","shiftBy","calcOffsets","n","window","wOpts","wbits","nextN","offsetStart","offset","abs","isZero","isNeg","isNegF","offsetF","pointPrecomputes","WeakMap","pointWindowSizes","getW","P","get","wNAF","c","hasPrecomputes","elm","unsafeLadder","p","ZERO","d","add","double","precomputeWindow","points","base","push","i","precomputes","f","BASE","wo","wNAFUnsafe","acc","getPrecomputes","transform","comp","this","set","wNAFCached","wNAFCachedUnsafe","prev","setWindowSize","delete","pippenger","fieldN","scalars","Array","isArray","forEach","validateMSMPoints","field","s","isValid","validateMSMScalars","plength","length","slength","zero","bitLen","MASK","buckets","fill","sum","floor","BITS","j","scalar","resI","sumI","validateBasic","curve","validateField","Fp","validateObject","h","Gx","Gy","nBitLength","nByteLength","Object","freeze","nLength","ORDER"],"mappings":"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","x_google_ignoreList":[0]}