import{validateBasic as t,pippenger as e,wNAF as n}from"./curve.mjs";import{Field as r,FpInvertBatch as i,mod as o}from"./modular.mjs";import{validateObject as s,memoized as a,aInRange as c,ensureBytes as u,abool as f,bytesToNumberLE as l,numberToBytesLE as h,bytesToHex as d,concatBytes as y}from"./utils.mjs";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const m=BigInt(0),p=BigInt(1),x=BigInt(2),w=BigInt(8),E={zip215:!0};function B(B){const g=function(e){const n=t(e);return s(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...n})}(B),{Fp:z,n:v,prehash:S,hash:R,randomBytes:A,nByteLength:b,h:O}=g,Z=x<<BigInt(8*b)-p,q=z.create,T=r(g.n,g.nBitLength);if(!function(t,e){const n=z.sqr(t),r=z.sqr(e),i=z.add(z.mul(g.a,n),r),o=z.add(z.ONE,z.mul(g.d,z.mul(n,r)));return z.eql(i,o)}(g.Gx,g.Gy))throw new Error("bad curve params: generator point");const H=g.uvRatio||((t,e)=>{try{return{isValid:!0,value:z.sqrt(t*z.inv(e))}}catch(t){return{isValid:!1,value:m}}}),P=g.adjustScalarBytes||(t=>t),U=g.domain||((t,e,n)=>{if(f("phflag",n),e.length||n)throw new Error("Contexts/pre-hash are not supported");return t});function j(t,e,n=!1){c("coordinate "+t,e,n?p:m,Z)}function C(t){if(!(t instanceof G))throw new Error("ExtendedPoint expected")}const Y=a(((t,e)=>{const{ex:n,ey:r,ez:i}=t,o=t.is0();null==e&&(e=o?w:z.inv(i));const s=q(n*e),a=q(r*e),c=q(i*e);if(o)return{x:m,y:p};if(c!==p)throw new Error("invZ was invalid");return{x:s,y:a}})),F=a((t=>{const{a:e,d:n}=g;if(t.is0())throw new Error("bad point: ZERO");const{ex:r,ey:i,ez:o,et:s}=t,a=q(r*r),c=q(i*i),u=q(o*o),f=q(u*u),l=q(a*e);if(q(u*q(l+c))!==q(f+q(n*q(a*c))))throw new Error("bad point: equation left != right (1)");if(q(r*i)!==q(o*s))throw new Error("bad point: equation left != right (2)");return!0}));class G{constructor(t,e,n,r){j("x",t),j("y",e),j("z",n,!0),j("t",r),this.ex=t,this.ey=e,this.ez=n,this.et=r,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof G)throw new Error("extended point not allowed");const{x:e,y:n}=t||{};return j("x",e),j("y",n),new G(e,n,p,q(e*n))}static normalizeZ(t){const e=i(z,t.map((t=>t.ez)));return t.map(((t,n)=>t.toAffine(e[n]))).map(G.fromAffine)}static msm(t,n){return e(G,T,t,n)}_setWindowSize(t){N.setWindowSize(this,t)}assertValidity(){F(this)}equals(t){C(t);const{ex:e,ey:n,ez:r}=this,{ex:i,ey:o,ez:s}=t,a=q(e*s),c=q(i*r),u=q(n*s),f=q(o*r);return a===c&&u===f}is0(){return this.equals(G.ZERO)}negate(){return new G(q(-this.ex),this.ey,this.ez,q(-this.et))}double(){const{a:t}=g,{ex:e,ey:n,ez:r}=this,i=q(e*e),o=q(n*n),s=q(x*q(r*r)),a=q(t*i),c=e+n,u=q(q(c*c)-i-o),f=a+o,l=f-s,h=a-o,d=q(u*l),y=q(f*h),m=q(u*h),p=q(l*f);return new G(d,y,p,m)}add(t){C(t);const{a:e,d:n}=g,{ex:r,ey:i,ez:o,et:s}=this,{ex:a,ey:c,ez:u,et:f}=t,l=q(r*a),h=q(i*c),d=q(s*n*f),y=q(o*u),m=q((r+i)*(a+c)-l-h),p=y-d,x=y+d,w=q(h-e*l),E=q(m*p),B=q(x*w),z=q(m*w),v=q(p*x);return new G(E,B,v,z)}subtract(t){return this.add(t.negate())}wNAF(t){return N.wNAFCached(this,t,G.normalizeZ)}multiply(t){const e=t;c("scalar",e,p,v);const{p:n,f:r}=this.wNAF(e);return G.normalizeZ([n,r])[0]}multiplyUnsafe(t,e=G.ZERO){const n=t;return c("scalar",n,m,v),n===m?K:this.is0()||n===p?this:N.wNAFCachedUnsafe(this,n,G.normalizeZ,e)}isSmallOrder(){return this.multiplyUnsafe(O).is0()}isTorsionFree(){return N.unsafeLadder(this,v).is0()}toAffine(t){return Y(this,t)}clearCofactor(){const{h:t}=g;return t===p?this:this.multiplyUnsafe(t)}static fromHex(t,e=!1){const{d:n,a:r}=g,i=z.BYTES;t=u("pointHex",t,i),f("zip215",e);const o=t.slice(),s=t[i-1];o[i-1]=-129&s;const a=l(o),h=e?Z:z.ORDER;c("pointHex.y",a,m,h);const d=q(a*a),y=q(d-p),x=q(n*d-r);let{isValid:w,value:E}=H(y,x);if(!w)throw new Error("Point.fromHex: invalid y coordinate");const B=(E&p)===p,v=!!(128&s);if(!e&&E===m&&v)throw new Error("Point.fromHex: x=0 and x_0=1");return v!==B&&(E=q(-E)),G.fromAffine({x:E,y:a})}static fromPrivateKey(t){const{scalar:e}=_(t);return I.multiply(e)}toRawBytes(){const{x:t,y:e}=this.toAffine(),n=h(e,z.BYTES);return n[n.length-1]|=t&p?128:0,n}toHex(){return d(this.toRawBytes())}}G.BASE=new G(g.Gx,g.Gy,p,q(g.Gx*g.Gy)),G.ZERO=new G(m,p,p,m);const{BASE:I,ZERO:K}=G,N=n(G,8*b);function V(t){return o(t,v)}function W(t){return V(l(t))}function _(t){const e=z.BYTES;t=u("private key",t,e);const n=u("hashed private key",R(t),2*e),r=P(n.slice(0,e));return{head:r,prefix:n.slice(e,2*e),scalar:W(r)}}function L(t){const{head:e,prefix:n,scalar:r}=_(t),i=I.multiply(r),o=i.toRawBytes();return{head:e,prefix:n,scalar:r,point:i,pointBytes:o}}function k(t=Uint8Array.of(),...e){const n=y(...e);return W(R(U(n,u("context",t),!!S)))}const D=E;I._setWindowSize(8);return{CURVE:g,getPublicKey:function(t){return L(t).pointBytes},sign:function(t,e,n={}){t=u("message",t),S&&(t=S(t));const{prefix:r,scalar:i,pointBytes:o}=L(e),s=k(n.context,r,t),a=I.multiply(s).toRawBytes(),f=V(s+k(n.context,a,o,t)*i);c("signature.s",f,m,v);const l=y(a,h(f,z.BYTES));return u("result",l,2*z.BYTES)},verify:function(t,e,n,r=D){const{context:i,zip215:o}=r,s=z.BYTES;t=u("signature",t,2*s),e=u("message",e),n=u("publicKey",n,s),void 0!==o&&f("zip215",o),S&&(e=S(e));const a=l(t.slice(s,2*s));let c,h,d;try{c=G.fromHex(n,o),h=G.fromHex(t.slice(0,s),o),d=I.multiplyUnsafe(a)}catch(t){return!1}if(!o&&c.isSmallOrder())return!1;const y=k(i,h.toRawBytes(),c.toRawBytes(),e);return h.add(c.multiplyUnsafe(y)).subtract(d).clearCofactor().equals(G.ZERO)},ExtendedPoint:G,utils:{getExtendedPublicKey:L,randomPrivateKey:()=>A(z.BYTES),precompute:(t=8,e=G.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}}export{B as twistedEdwards};
//# sourceMappingURL=edwards.mjs.map
