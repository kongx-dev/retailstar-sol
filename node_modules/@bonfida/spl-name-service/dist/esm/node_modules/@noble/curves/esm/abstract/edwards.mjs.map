{"version":3,"file":"edwards.mjs","sources":["../../../../../../../node_modules/@noble/curves/esm/abstract/edwards.js"],"sourcesContent":["/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport { pippenger, validateBasic, wNAF } from \"./curve.js\";\nimport { Field, FpInvertBatch, mod } from \"./modular.js\";\n// prettier-ignore\nimport { abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes, ensureBytes, memoized, numberToBytesLE, validateObject } from \"./utils.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\n    function isEdValidXY(x, y) {\n        const x2 = Fp.sqr(x);\n        const y2 = Fp.sqr(y);\n        const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n        const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // equation ax² + y² = 1 + dx²y² should work for generator point.\n    if (!isEdValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            abool('phflag', phflag);\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // 0 <= n < MASK\n    // Coordinates larger than Fp.ORDER are allowed for zip215\n    function aCoordinate(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        aInRange('coordinate ' + title, n, min, MASK);\n    }\n    function aextpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = memoized((p, iz) => {\n        const { ex: x, ey: y, ez: z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        const ax = modP(x * iz);\n        const ay = modP(y * iz);\n        const zz = modP(z * iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    const assertValidMemo = memoized((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = modP(X * X); // X²\n        const Y2 = modP(Y * Y); // Y²\n        const Z2 = modP(Z * Z); // Z²\n        const Z4 = modP(Z2 * Z2); // Z⁴\n        const aX2 = modP(X2 * a); // aX²\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            aCoordinate('x', ex);\n            aCoordinate('y', ey);\n            aCoordinate('z', ez, true);\n            aCoordinate('t', et);\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            Object.freeze(this);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            aCoordinate('x', x);\n            aCoordinate('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = FpInvertBatch(Fp, points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aextpoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aextpoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const n = scalar;\n            aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n            const { p, f } = this.wNAF(n);\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            const n = scalar;\n            aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n            if (n === _0n)\n                return I;\n            if (this.is0() || n === _1n)\n                return this;\n            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n            abool('zip215', zip215);\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = bytesToNumberLE(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            aInRange('pointHex.y', y, _0n, max);\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            const { scalar } = getPrivateScalar(privKey);\n            return G.multiply(scalar); // reduced one call of `toRawBytes`\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = wNAF(Point, nByteLength * 8);\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(bytesToNumberLE(hash));\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = Fp.BYTES;\n        key = ensureBytes('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return { head, prefix, scalar };\n    }\n    // Convenience method that creates public key from scalar. RFC8032 5.1.5\n    function getExtendedPublicKey(key) {\n        const { head, prefix, scalar } = getPrivateScalar(key);\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n        const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n        return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = ensureBytes('message', msg);\n        publicKey = ensureBytes('publicKey', publicKey, len);\n        if (zip215 !== undefined)\n            abool('zip215', zip215);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = bytesToNumberLE(sig.slice(len, 2 * len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map"],"names":["_0n","BigInt","_1n","_2n","_8n","VERIFY_DEFAULT","zip215","twistedEdwards","curveDef","CURVE","curve","opts","validateBasic","validateObject","hash","a","d","randomBytes","adjustScalarBytes","domain","uvRatio","mapToCurve","Object","freeze","validateOpts","Fp","n","CURVE_ORDER","prehash","cHash","nByteLength","h","cofactor","MASK","modP","create","Fn","Field","nBitLength","x","y","x2","sqr","y2","left","add","mul","right","ONE","eql","isEdValidXY","Gx","Gy","Error","u","v","isValid","value","sqrt","inv","e","bytes","data","ctx","phflag","abool","length","aCoordinate","title","banZero","aInRange","aextpoint","other","Point","toAffineMemo","memoized","p","iz","ex","ey","ez","z","is0","ax","ay","zz","assertValidMemo","X","Y","Z","et","T","X2","Y2","Z2","Z4","aX2","constructor","this","toAffine","fromAffine","normalizeZ","points","toInv","FpInvertBatch","map","i","msm","scalars","pippenger","_setWindowSize","windowSize","wnaf","setWindowSize","assertValidity","equals","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","ZERO","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","subtract","wNAF","wNAFCached","multiply","scalar","f","multiplyUnsafe","acc","I","wNAFCachedUnsafe","isSmallOrder","isTorsionFree","unsafeLadder","clearCofactor","fromHex","hex","len","BYTES","ensureBytes","normed","slice","lastByte","bytesToNumberLE","max","ORDER","isXOdd","isLastByteOdd","fromPrivateKey","privKey","getPrivateScalar","toRawBytes","numberToBytesLE","toHex","bytesToHex","BASE","modN","mod","modN_LE","key","hashed","head","prefix","getExtendedPublicKey","point","pointBytes","hashDomainToScalar","context","Uint8Array","of","msgs","msg","concatBytes","verifyOpts","getPublicKey","sign","options","r","R","s","res","verify","sig","publicKey","undefined","SB","error","k","ExtendedPoint","utils","randomPrivateKey","precompute"],"mappings":"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","x_google_ignoreList":[0]}