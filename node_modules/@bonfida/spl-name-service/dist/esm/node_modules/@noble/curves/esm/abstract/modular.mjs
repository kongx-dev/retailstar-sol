import{anumber as r}from"../../../hashes/esm/utils.mjs";import{numberToBytesLE as t,numberToBytesBE as e,bitMask as n,bytesToNumberLE as o,bytesToNumberBE as i,validateObject as s}from"./utils.mjs";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u=BigInt(0),f=BigInt(1),l=BigInt(2),d=BigInt(3),c=BigInt(4),w=BigInt(5),E=BigInt(8);function g(r,t){const e=r%t;return e>=u?e:t+e}function a(r,t,e){let n=r;for(;t-- >u;)n*=n,n%=e;return n}function m(r,t){if(r===u)throw new Error("invert: expected non-zero number");if(t<=u)throw new Error("invert: expected positive modulus, got "+t);let e=g(r,t),n=t,o=u,i=f;for(;e!==u;){const r=n%e,t=o-i*(n/e);n=e,e=r,o=i,i=t}if(n!==f)throw new Error("invert: does not exist");return g(o,t)}function h(r,t){const e=(r.ORDER+f)/c,n=r.pow(t,e);if(!r.eql(r.sqr(n),t))throw new Error("Cannot find square root");return n}function q(r,t){const e=(r.ORDER-w)/E,n=r.mul(t,l),o=r.pow(n,e),i=r.mul(t,o),s=r.mul(r.mul(i,l),o),u=r.mul(i,r.sub(s,r.ONE));if(!r.eql(r.sqr(u),t))throw new Error("Cannot find square root");return u}function p(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let t=r-f,e=0;for(;t%l===u;)t/=l,e++;let n=l;const o=x(r);for(;1===I(o,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===e)return h;let i=o.pow(n,t);const s=(t+f)/l;return function(r,n){if(r.is0(n))return n;if(1!==I(r,n))throw new Error("Cannot find square root");let o=e,u=r.mul(r.ONE,i),l=r.pow(n,t),d=r.pow(n,s);for(;!r.eql(l,r.ONE);){if(r.is0(l))return r.ZERO;let t=1,e=r.sqr(l);for(;!r.eql(e,r.ONE);)if(t++,e=r.sqr(e),t===o)throw new Error("Cannot find square root");const n=f<<BigInt(o-t-1),i=r.pow(u,n);o=t,u=r.sqr(i),l=r.mul(l,u),d=r.mul(d,i)}return d}}function O(r){return r%c===d?h:r%E===w?q:p(r)}const B=(r,t)=>(g(r,t)&f)===f,v=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function R(r){const t=v.reduce(((r,t)=>(r[t]="function",r)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return s(r,t)}function N(r,t,e){if(e<u)throw new Error("invalid exponent, negatives unsupported");if(e===u)return r.ONE;if(e===f)return t;let n=r.ONE,o=t;for(;e>u;)e&f&&(n=r.mul(n,o)),o=r.sqr(o),e>>=f;return n}function b(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),o=t.reduce(((t,e,o)=>r.is0(e)?t:(n[o]=t,r.mul(t,e))),r.ONE),i=r.inv(o);return t.reduceRight(((t,e,o)=>r.is0(e)?t:(n[o]=r.mul(t,n[o]),r.mul(t,e))),i),n}function I(r,t){const e=(r.ORDER-f)/l,n=r.pow(t,e),o=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),s=r.eql(n,r.neg(r.ONE));if(!o&&!i&&!s)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function y(t,e){void 0!==e&&r(e);const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function x(r,s,l=!1,d={}){if(r<=u)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:c,nByteLength:w}=y(r,s);if(w>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let E;const a=Object.freeze({ORDER:r,isLE:l,BITS:c,BYTES:w,MASK:n(c),ZERO:u,ONE:f,create:t=>g(t,r),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return u<=t&&t<r},is0:r=>r===u,isOdd:r=>(r&f)===f,neg:t=>g(-t,r),eql:(r,t)=>r===t,sqr:t=>g(t*t,r),add:(t,e)=>g(t+e,r),sub:(t,e)=>g(t-e,r),mul:(t,e)=>g(t*e,r),pow:(r,t)=>N(a,r,t),div:(t,e)=>g(t*m(e,r),r),sqrN:r=>r*r,addN:(r,t)=>r+t,subN:(r,t)=>r-t,mulN:(r,t)=>r*t,inv:t=>m(t,r),sqrt:d.sqrt||(t=>(E||(E=O(r)),E(a,t))),toBytes:r=>l?t(r,w):e(r,w),fromBytes:r=>{if(r.length!==w)throw new Error("Field.fromBytes: expected "+w+" bytes, got "+r.length);return l?o(r):i(r)},invertBatch:r=>b(a,r),cmov:(r,t,e)=>e?t:r});return Object.freeze(a)}export{x as Field,b as FpInvertBatch,I as FpLegendre,N as FpPow,O as FpSqrt,m as invert,B as isNegativeLE,g as mod,y as nLength,a as pow2,p as tonelliShanks,R as validateField};
//# sourceMappingURL=modular.mjs.map
