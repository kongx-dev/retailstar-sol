/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const t=BigInt(0),r=BigInt(1);function n(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function e(t){if(!n(t))throw new Error("Uint8Array expected")}function o(t,r){if("boolean"!=typeof r)throw new Error(t+" boolean expected, got "+r)}function i(r){if("string"!=typeof r)throw new Error("hex string expected, got "+typeof r);return""===r?t:BigInt("0x"+r)}const f="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,c=Array.from({length:256},((t,r)=>r.toString(16).padStart(2,"0")));function u(t){if(e(t),f)return t.toHex();let r="";for(let n=0;n<t.length;n++)r+=c[t[n]];return r}const s=48,a=57,g=65,h=70,y=97,p=102;function l(t){return t>=s&&t<=a?t-s:t>=g&&t<=h?t-(g-10):t>=y&&t<=p?t-(y-10):void 0}function d(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(f)return Uint8Array.fromHex(t);const r=t.length,n=r/2;if(r%2)throw new Error("hex string expected, got unpadded hex of length "+r);const e=new Uint8Array(n);for(let r=0,o=0;r<n;r++,o+=2){const n=l(t.charCodeAt(o)),i=l(t.charCodeAt(o+1));if(void 0===n||void 0===i){const r=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+r+'" at index '+o)}e[r]=16*n+i}return e}function w(t){return i(u(t))}function x(t){return e(t),i(u(Uint8Array.from(t).reverse()))}function A(t,r){return d(t.toString(16).padStart(2*r,"0"))}function b(t,r){return A(t,r).reverse()}function m(t,r,e){let o;if("string"==typeof r)try{o=d(r)}catch(r){throw new Error(t+" must be hex string or Uint8Array, cause: "+r)}else{if(!n(r))throw new Error(t+" must be hex string or Uint8Array");o=Uint8Array.from(r)}const i=o.length;if("number"==typeof e&&i!==e)throw new Error(t+" of length "+e+" expected, got "+i);return o}function E(...t){let r=0;for(let n=0;n<t.length;n++){const o=t[n];e(o),r+=o.length}const n=new Uint8Array(r);for(let r=0,e=0;r<t.length;r++){const o=t[r];n.set(o,e),e+=o.length}return n}const U=r=>"bigint"==typeof r&&t<=r;function v(t,r,n){return U(t)&&U(r)&&U(n)&&r<=t&&t<n}function S(t,r,n,e){if(!v(r,n,e))throw new Error("expected valid "+t+": "+n+" <= n < "+e+", got "+r)}function I(n){let e;for(e=0;n>t;n>>=r,e+=1);return e}const B=t=>(r<<BigInt(t))-r,H={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||n(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,r)=>r.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function O(t,r,n={}){const e=(r,n,e)=>{const o=H[n];if("function"!=typeof o)throw new Error("invalid validator function");const i=t[r];if(!(e&&void 0===i||o(i,t)))throw new Error("param "+String(r)+" is invalid. Expected "+n+", got "+i)};for(const[t,n]of Object.entries(r))e(t,n,!1);for(const[t,r]of Object.entries(n))e(t,r,!0);return t}function j(t){const r=new WeakMap;return(n,...e)=>{const o=r.get(n);if(void 0!==o)return o;const i=t(n,...e);return r.set(n,i),i}}export{S as aInRange,o as abool,e as abytes,I as bitLen,B as bitMask,u as bytesToHex,w as bytesToNumberBE,x as bytesToNumberLE,E as concatBytes,m as ensureBytes,d as hexToBytes,i as hexToNumber,v as inRange,n as isBytes,j as memoized,A as numberToBytesBE,b as numberToBytesLE,O as validateObject};
//# sourceMappingURL=utils.mjs.map
