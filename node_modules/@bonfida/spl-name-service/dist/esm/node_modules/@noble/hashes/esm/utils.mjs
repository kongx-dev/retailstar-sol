import{crypto as e}from"./crypto.mjs";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function t(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function n(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function r(e,...n){if(!t(e))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(e.length))throw new Error("Uint8Array expected of length "+n+", got length="+e.length)}function o(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function i(e,t){r(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function f(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function u(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function c(e,t){return e<<32-t|e>>>t}function a(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}function s(e){return"string"==typeof e&&(e=a(e)),r(e),e}class d{}function g(e){const t=t=>e().update(s(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function h(t=32){if(e&&"function"==typeof e.getRandomValues)return e.getRandomValues(new Uint8Array(t));if(e&&"function"==typeof e.randomBytes)return Uint8Array.from(e.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}export{d as Hash,r as abytes,o as aexists,n as anumber,i as aoutput,f as clean,g as createHasher,u as createView,t as isBytes,h as randomBytes,c as rotr,s as toBytes,a as utf8ToBytes};
//# sourceMappingURL=utils.mjs.map
